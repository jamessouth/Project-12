{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/workbox-core/_version.mjs","webpack:///./node_modules/workbox-core/_private/cacheNames.mjs","webpack:///./node_modules/workbox-core/_private/getFriendlyURL.mjs","webpack:///./node_modules/workbox-core/models/messages/messageGenerator.mjs","webpack:///./node_modules/workbox-core/_private/WorkboxError.mjs","webpack:///./node_modules/workbox-core/_private/assert.mjs","webpack:///./node_modules/workbox-core/models/pluginEvents.mjs","webpack:///./node_modules/workbox-core/utils/pluginUtils.mjs","webpack:///./node_modules/workbox-core/_private/quota.mjs","webpack:///./node_modules/workbox-core/_private/cacheWrapper.mjs","webpack:///./node_modules/workbox-core/_private/fetchWrapper.mjs","webpack:///./node_modules/workbox-precaching/_version.mjs","webpack:///./node_modules/workbox-precaching/utils/createCacheKey.mjs","webpack:///./node_modules/workbox-precaching/PrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/cleanRedirect.mjs","webpack:///./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/getCacheKeyForURL.mjs","webpack:///./node_modules/workbox-precaching/utils/generateURLVariations.mjs","webpack:///./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.mjs","webpack:///./node_modules/workbox-precaching/addRoute.mjs","webpack:///./node_modules/workbox-precaching/utils/precachePlugins.mjs","webpack:///./node_modules/workbox-precaching/precache.mjs","webpack:///./node_modules/workbox-routing/_version.mjs","webpack:///./node_modules/workbox-routing/utils/constants.mjs","webpack:///./node_modules/workbox-routing/utils/normalizeHandler.mjs","webpack:///./node_modules/workbox-routing/Route.mjs","webpack:///./node_modules/workbox-routing/RegExpRoute.mjs","webpack:///./node_modules/workbox-routing/Router.mjs","webpack:///./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs","webpack:///./node_modules/workbox-routing/registerRoute.mjs","webpack:///./node_modules/workbox-strategies/_version.mjs","webpack:///./node_modules/workbox-strategies/CacheFirst.mjs","webpack:///./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs","webpack:///./node_modules/workbox-strategies/StaleWhileRevalidate.mjs","webpack:///./node_modules/workbox-core/_private/DBWrapper.mjs","webpack:///./node_modules/workbox-core/_private/deleteDatabase.mjs","webpack:///./node_modules/workbox-expiration/_version.mjs","webpack:///./node_modules/workbox-expiration/models/CacheTimestampsModel.mjs","webpack:///./node_modules/workbox-expiration/CacheExpiration.mjs","webpack:///./node_modules/workbox-expiration/Plugin.mjs","webpack:///./node_modules/workbox-core/skipWaiting.mjs","webpack:///./node_modules/workbox-core/clientsClaim.mjs","webpack:///./src/sw-predicate.js","webpack:///./node_modules/workbox-core/setCacheNameDetails.mjs","webpack:///./node_modules/workbox-precaching/precacheAndRoute.mjs","webpack:///./node_modules/workbox-routing/setDefaultHandler.mjs","webpack:///./node_modules/workbox-precaching/cleanupOutdatedCaches.mjs","webpack:///./node_modules/workbox-precaching/utils/deleteOutdatedCaches.mjs","webpack:///./node_modules/workbox-routing/setCatchHandler.mjs"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","_","e","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","length","join","cacheNames","updateDetails","details","keys","forEach","getGoogleAnalyticsName","userCacheName","getPrecacheName","getRuntimeName","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","messageGenerator","code","args","msg","JSON","stringify","WorkboxError_WorkboxError","Error","[object Object]","errorCode","super","this","pluginEvents","pluginUtils","plugins","callbackName","plugin","callbacks","Set","matchWrapper","async","request","event","matchOptions","cache","caches","open","cachedResponse","match","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","cacheWrapper","put","updatePlugins","oldResponse","error","callback","executeQuotaErrorCallbacks","newResponse","fetchWrapper","fetch","fetchOptions","preloadResponse","possiblePreloadResponse","Request","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","REVISION_SEARCH_PARAM","createCacheKey","entry","urlObject","cacheKey","revision","originalURL","cacheKeyURL","searchParams","set","PrecacheController_PrecacheController","_cacheName","_urlsToCacheKeys","Map","entries","has","firstEntry","secondEntry","urlsToPrecache","urlsAlreadyPrecached","alreadyCachedRequests","alreadyCachedURLs","map","values","push","precacheRequests","_addURLToCache","Promise","all","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","deletedURLs","delete","credentials","cacheWillUpdateCallback","cacheWillUpdate","redirected","clonedResponse","bodyPromise","resolve","body","blob","Response","headers","statusText","cleanRedirect","ignoreSearch","getOrCreatePrecacheController_precacheController","getOrCreatePrecacheController","getCacheKeyForURL","options","urlsToCacheKeys","getURLsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","hash","urlWithoutIgnoredParams","paramName","some","regExp","test","removeIgnoredSearchParams","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","possibleCacheKey","listenerAdded","precachePlugins_plugins","precachePlugins","newPlugins","listenersAdded","defaultMethod","normalizeHandler","handler","handle","Route_Route","method","RegExpRoute_RegExpRoute","result","exec","index","slice","Router_Router","_routes","routes","addEventListener","responsePromise","handleRequest","respondWith","data","type","payload","requestPromises","urlsToCache","waitUntil","ports","postMessage","protocol","startsWith","params","route","findMatchingRoute","_defaultHandler","reject","_catchHandler","catch","matchResult","Array","isArray","constructor","routeIndex","indexOf","splice","getOrCreateDefaultRouter_defaultRouter","getOrCreateDefaultRouter","addFetchListener","addCacheListener","registerRoute","capture","captureUrl","RegExp","moduleName","funcName","CacheFirst_CacheFirst","_plugins","_fetchOptions","_matchOptions","makeRequest","_getFromNetwork","responseClone","cachePutPromise","cacheOkAndOpaquePlugin","StaleWhileRevalidate_StaleWhileRevalidate","isUsingCacheWillUpdate","fetchAndCachePromise","DBWrapper","version","onupgradeneeded","onversionchange","_onversionchange","_name","_version","_onupgradeneeded","_db","db","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","onerror","evt","transaction","abort","target","close","onsuccess","storeName","query","getAllKeys","count","getAllMatching","includeKeys","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","continue","storeNames","onabort","oncomplete","methodsToWrap","readonly","readwrite","methods","IDBObjectStore","_call","deleteDatabase","onblocked","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","CacheTimestampsModel_CacheTimestampsModel","_handleUpgrade","objStore","createObjectStore","keyPath","createIndex","unique","timestamp","id","_getId","minTimestamp","maxCount","entriesDeleted","entriesNotDeletedCount","CacheExpiration_CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_timestampModel","Date","now","undefined","urlsExpired","expireEntries","setTimestamp","getTimestamp","Infinity","Plugin_Plugin","_config","_cacheExpirations","purgeOnQuotaError","deleteCacheAndMetadata","add","cacheExpiration","isFresh","_isResponseDateFresh","_getCacheExpiration","updateTimestampDone","updateTimestamp","dateHeaderTimestamp","_getDateHeaderTimestamp","dateHeader","headerTime","getTime","isNaN","skipWaiting","clients","claim","__precacheManifest","concat","precacheController","addToCacheList","install","activate","precachedURL","then","addRoute","currentPrecacheName","substringToFind","cacheNamesToDelete","includes","deleteOutdatedCaches","cachesDeleted","setDefaultHandler","setCatchHandler","console","log","destination"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","try{self['workbox:core:4.0.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\n\nimport '../_version.mjs';\n\nconst callbacks = new Set();\n\n/**\n * Adds a function to the set of callbacks that will be executed when there's\n * a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  callbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${callbacks.size} callbacks to clean up caches.`);\n  }\n\n  for (const callback of callbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {\n  executeQuotaErrorCallbacks,\n  registerQuotaErrorCallback,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {executeQuotaErrorCallbacks} from './quota.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(request.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(request.url),\n    });\n  }\n\n  let responseToCache =\n      await _isResponseSafeToCache({request, response, event, plugins});\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(request.url)}' will not be ` +\n        `cached.`, responseToCache);\n    }\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (responseToCache.method && responseToCache.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: responseToCache.method,\n      });\n    }\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n    await matchWrapper({cacheName, request, matchOptions}) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(request.url)}.`);\n  }\n\n  try {\n    await cache.put(request, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      request,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n  let cachedResponse = await cache.match(request, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            request,\n            event,\n            matchOptions,\n            cachedResponse,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","try{self['workbox:precaching:4.0.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport '../_version.mjs';\n\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  const {revision, url} = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const originalURL = new URL(url, location);\n  const cacheKeyURL = new URL(url, location);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href,\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate;\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport async function cleanRedirect(response) {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, {\n    headers: clonedResponse.headers,\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n  });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {PrecacheController} from '../PrecacheController.mjs';\nimport '../_version.mjs';\n\n\nlet precacheController;\n\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './getOrCreatePrecacheController.mjs';\nimport {generateURLVariations} from './generateURLVariations.mjs';\nimport '../_version.mjs';\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n  const precacheController = getOrCreatePrecacheController();\n\n  const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n  for (const possibleURL of generateURLVariations(url, options)) {\n    const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n    if (possibleCacheKey) {\n      return possibleCacheKey;\n    }\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {removeIgnoredSearchParams} from './removeIgnoredSearchParams.mjs';\n\nimport '../_version.mjs';\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, {\n  ignoreURLParametersMatching,\n  directoryIndex,\n  cleanURLs,\n  urlManipulation,\n} = {}) {\n  const urlObject = new URL(url, location);\n  urlObject.hash = '';\n  yield urlObject.href;\n\n  const urlWithoutIgnoredParams = removeIgnoredSearchParams(\n      urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({url: urlObject});\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject,\n    ignoreURLParametersMatching) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './utils/getCacheKeyForURL.mjs';\nimport './_version.mjs';\n\n\nlet listenerAdded = false;\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  if (!listenerAdded) {\n    const cacheName = cacheNames.getPrecacheName();\n\n    addEventListener('fetch', (event) => {\n      const precachedURL = getCacheKeyForURL(event.request.url, {\n        cleanURLs,\n        directoryIndex,\n        ignoreURLParametersMatching,\n        urlManipulation,\n      });\n      if (!precachedURL) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Precaching did not find a match for ` +\n            getFriendlyURL(event.request.url));\n        }\n        return;\n      }\n\n      let responsePromise = caches.open(cacheName).then((cache) => {\n        return cache.match(precachedURL);\n      }).then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        // Fall back to the network if we don't have a cached response\n        // (perhaps due to manual cache cleanup).\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`The precached response for ` +\n          `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n          `Falling back to the network instead.`);\n        }\n\n        return fetch(precachedURL);\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        responsePromise = responsePromise.then((response) => {\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Precaching is responding to: ` +\n            getFriendlyURL(event.request.url));\n          logger.log(`Serving the precached url: ${precachedURL}`);\n\n          logger.groupCollapsed(`View request details here.`);\n          logger.log(event.request);\n          logger.groupEnd();\n\n          logger.groupCollapsed(`View response details here.`);\n          logger.log(response);\n          logger.groupEnd();\n\n          logger.groupEnd();\n          return response;\n        });\n      }\n\n      event.respondWith(responsePromise);\n    });\n\n    listenerAdded = true;\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst plugins = [];\n\nexport const precachePlugins = {\n  /*\n   * @return {Array}\n   * @private\n   */\n  get() {\n    return plugins;\n  },\n\n  /*\n   * @param {Array} newPlugins\n   * @private\n   */\n  add(newPlugins) {\n    plugins.push(...newPlugins);\n  },\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getOrCreatePrecacheController}\n  from './utils/getOrCreatePrecacheController.mjs';\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\nlet listenersAdded = false;\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.addToCacheList(entries);\n\n  if (!listenersAdded && entries.length > 0) {\n    const plugins = precachePlugins.get();\n\n    self.addEventListener('install', (event) => {\n      event.waitUntil(\n          precacheController.install({event, plugins})\n              .catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.error(`Service worker installation failed. It will ` +\n                  `be retried automatically during the next navigation.`);\n                }\n                // Re-throw the error to ensure installation fails.\n                throw error;\n              })\n      );\n    });\n\n    self.addEventListener('activate', (event) => {\n      event.waitUntil(precacheController.activate({event, plugins}));\n    });\n\n    listenersAdded = true;\n  }\n};\n","try{self['workbox:routing:4.0.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'PATCH',\n  'POST',\n  'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport '../_version.mjs';\n\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return {handle: handler};\n  }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox.routing.Route~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match',\n      });\n\n      if (method) {\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\n      }\n    }\n\n    // These values are referenced directly by Router so cannot be\n    // altered by minifification.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method || defaultMethod;\n  }\n}\n\nexport {Route};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from './Route.mjs';\nimport './_version.mjs';\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regulard expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * th ecaptured values will be passed to the\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern',\n      });\n    }\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if there's no match.\n      if (!result) {\n        return null;\n      }\n\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\n              `The regular expression '${regExp}' only partially matched ` +\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n            `handle cross-origin requests if they match the entire URL.`\n          );\n        }\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n}\n\nexport {RegExpRoute};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\n\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    self.addEventListener('fetch', (event) => {\n      const {request} = event;\n      const responsePromise = this.handleRequest({request, event});\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    self.addEventListener('message', async (event) => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {payload} = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({request});\n        }));\n\n        event.waitUntil(requestPromises);\n\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest({request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request',\n      });\n    }\n\n    const url = new URL(request.url, location);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n            `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let {params, route} = this.findMatchingRoute({url, request, event});\n    let handler = route && route.handler;\n\n    let debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n\n      logger.groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, request, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` +\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute({url, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request',\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({url, request, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if ((matchResult.constructor === Object &&\n            Object.keys(matchResult).length > 0)) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        }\n\n        // Return early if have a match.\n        return {route, params};\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError(\n          'unregister-route-but-not-found-with-method', {\n            method: route.method,\n          }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\n\nexport {Router};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Router} from '../Router.mjs';\nimport '../_version.mjs';\n\nlet defaultRouter;\n\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new Router();\n\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {Route} from './Route.mjs';\nimport {RegExpRoute} from './RegExpRoute.mjs';\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nexport const registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture',\n        });\n      }\n\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname : capture;\n\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        logger.debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n          `character (${wildcards}). Strings are now always interpreted as ` +\n          `exact matches; use a RegExp for partial or wildcard matches.`\n        );\n      }\n    }\n\n    const matchCallback = ({url}) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if ((url.pathname === captureUrl.pathname) &&\n            (url.origin !== captureUrl.origin)) {\n          logger.debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture',\n    });\n  }\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n","try{self['workbox:strategies:4.0.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {StaleWhileRevalidate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange;\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   */\n  close() {\n    if (this._db) this._db.close();\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","try{self['workbox:expiration:4.0.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    return await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesDeleted = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      cursor.delete();\n                      // We only need to return the URL, not the whole entry.\n                      entriesDeleted.push(cursor.value.url);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesDeleted);\n                }\n              };\n        });\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the last request to be used will be the request\n * that is removed from the Cache.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Force a service worker to become active, instead of waiting. This is\n * normally used in conjunction with `clientsClaim()`.\n *\n * @alias workbox.core.skipWaiting\n */\nexport const skipWaiting = () => {\n  // We need to explicitly call `self.skipWaiting()` here because we're\n  // shadowing `skipWaiting` with this local function.\n  addEventListener('install', () => self.skipWaiting());\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @alias workbox.core.clientsClaim\n */\nexport const clientsClaim = () => {\n  addEventListener('activate', () => clients.claim());\n};\n","/* eslint-disable no-undef, no-restricted-globals, no-underscore-dangle */\r\nimport { precacheAndRoute } from 'workbox-precaching/precacheAndRoute.mjs';\r\nimport { cleanupOutdatedCaches } from 'workbox-precaching/cleanupOutdatedCaches.mjs';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.mjs';\r\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.mjs';\r\nimport { setDefaultHandler } from 'workbox-routing/setDefaultHandler.mjs';\r\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.mjs';\r\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.mjs';\r\nimport { Plugin as ExpirationPlugin } from 'workbox-expiration/Plugin.mjs';\r\nimport { setCacheNameDetails } from 'workbox-core/setCacheNameDetails.mjs';\r\nimport { clientsClaim } from 'workbox-core/clientsClaim.mjs';\r\nimport { skipWaiting } from 'workbox-core/skipWaiting.mjs';\r\n\r\n\r\nskipWaiting();\r\nclientsClaim();\r\n\r\n\r\nconst prefix = 'james south portfolio';\r\nconst FALLBACK_IMAGE_7_URL = '/images/project7.0d460c6cd15e9ed3f683a05d1a282fbb.jpg';\r\nconst FALLBACK_IMAGE_9_URL = '/images/project9.fef701d08faf6c81fe7b50e9c45f79ad.jpg';\r\nconst FALLBACK_IMAGE_10_URL = '/images/project10.38128e3e605efa9c9dc9aecec6ffe3f7.jpg';\r\nconst FALLBACK_IMAGE_11_URL = '/images/project11.f50561f0701ba64315826deee4556c17.jpg';\r\n\r\n\r\nsetCacheNameDetails({ prefix });\r\n\r\nself.__precacheManifest = [].concat(self.__precacheManifest || []);\r\n\r\nprecacheAndRoute(self.__precacheManifest, {});\r\n\r\ncleanupOutdatedCaches();\r\n\r\n\r\nregisterRoute(\r\n  /\\.(?:js)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-lazy-js`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\n\r\nregisterRoute(\r\n  /\\.(?:png|jpg|jpeg|svg|gif)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-images`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 180,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.googleapis\\.com/,\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-google-fonts-css`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 30,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.gstatic\\.com/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-google-fonts`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nsetDefaultHandler(\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-default-handler`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\n\r\nsetCatchHandler(({ event }) => {\r\n  console.log(event.request);\r\n  if (event.request.destination === 'image' && /\\.gif$/.test(event.request.url) && !event.request.url.includes('explosion')) {\r\n    switch (event.request.url.match(/\\d{1,2}(?=\\.\\w{32})/)[0]) {\r\n      case '7':\r\n        return caches.match(FALLBACK_IMAGE_7_URL);\r\n      case '9':\r\n        return caches.match(FALLBACK_IMAGE_9_URL);\r\n      case '10':\r\n        return caches.match(FALLBACK_IMAGE_10_URL);\r\n      case '11':\r\n        return caches.match(FALLBACK_IMAGE_11_URL);\r\n    }\r\n  }\r\n  return Response.error();\r\n});\r\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addRoute} from './addRoute.mjs';\nimport {precache} from './precache.mjs';\nimport './_version.mjs';\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n  precache(entries);\n  addRoute(options);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\n\nimport './_version.mjs';\n\n/**\n * Define a default `handler` that's called when no routes explicitly\n * match the incoming request.\n *\n * Without a default handler, unmatched requests will go against the\n * network as if there were no service worker present.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setDefaultHandler\n */\nexport const setDefaultHandler = (handler) => {\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.setDefaultHandler(handler);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {deleteOutdatedCaches} from './utils/deleteOutdatedCaches.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @alias workbox.precaching.cleanupOutdatedCaches\n */\nexport const cleanupOutdatedCaches = () => {\n  addEventListener('activate', (event) => {\n    const cacheName = cacheNames.getPrecacheName();\n\n    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachesDeleted.length > 0) {\n          logger.log(`The following out-of-date precaches were cleaned up ` +\n              `automatically:`, cachesDeleted);\n        }\n      }\n    }));\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst SUBSTRING_TO_FIND = '-precache-';\n\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nconst deleteOutdatedCaches = async (\n  currentPrecacheName,\n  substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await caches.keys();\n\n  const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n    return cacheName.includes(substringToFind) &&\n           cacheName.includes(self.registration.scope) &&\n           cacheName !== currentPrecacheName;\n  });\n\n  await Promise.all(\n      cacheNamesToDelete.map((cacheName) => caches.delete(cacheName)));\n\n  return cacheNamesToDelete;\n};\n\nexport {deleteOutdatedCaches};\n\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\n\nimport './_version.mjs';\n\n/**\n * If a Route throws an error while handling a request, this `handler`\n * will be called and given a chance to provide a response.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setCatchHandler\n */\nexport const setCatchHandler = (handler) => {\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.setCatchHandler(handler);\n};\n"],"sourceRoot":""}