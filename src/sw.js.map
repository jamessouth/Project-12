{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/workbox-core/_version.mjs","webpack:///./node_modules/workbox-core/models/messages/messages.mjs","webpack:///./node_modules/workbox-core/models/messages/messageGenerator.mjs","webpack:///./node_modules/workbox-core/_private/WorkboxError.mjs","webpack:///./node_modules/workbox-core/_private/assert.mjs","webpack:///./node_modules/workbox-core/_private/cacheNames.mjs","webpack:///./node_modules/workbox-core/_private/getFriendlyURL.mjs","webpack:///./node_modules/workbox-core/_private/quota.mjs","webpack:///./node_modules/workbox-core/_private/DBWrapper.mjs","webpack:///./node_modules/workbox-core/_private/deleteDatabase.mjs","webpack:///./node_modules/workbox-expiration/_version.mjs","webpack:///./node_modules/workbox-expiration/models/CacheTimestampsModel.mjs","webpack:///./node_modules/workbox-expiration/CacheExpiration.mjs","webpack:///./node_modules/workbox-expiration/Plugin.mjs","webpack:///./node_modules/workbox-precaching/_version.mjs","webpack:///./node_modules/workbox-precaching/utils/deleteOutdatedCaches.mjs","webpack:///./node_modules/workbox-core/models/pluginEvents.mjs","webpack:///./node_modules/workbox-core/utils/pluginUtils.mjs","webpack:///./node_modules/workbox-core/_private/cacheWrapper.mjs","webpack:///./node_modules/workbox-core/_private/fetchWrapper.mjs","webpack:///./node_modules/workbox-precaching/utils/createCacheKey.mjs","webpack:///./node_modules/workbox-precaching/PrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/cleanRedirect.mjs","webpack:///./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/getCacheKeyForURL.mjs","webpack:///./node_modules/workbox-precaching/utils/generateURLVariations.mjs","webpack:///./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.mjs","webpack:///./node_modules/workbox-precaching/addRoute.mjs","webpack:///./node_modules/workbox-precaching/utils/precachePlugins.mjs","webpack:///./node_modules/workbox-precaching/precache.mjs","webpack:///./node_modules/workbox-routing/_version.mjs","webpack:///./node_modules/workbox-routing/utils/constants.mjs","webpack:///./node_modules/workbox-routing/utils/normalizeHandler.mjs","webpack:///./node_modules/workbox-routing/Route.mjs","webpack:///./node_modules/workbox-routing/RegExpRoute.mjs","webpack:///./node_modules/workbox-routing/Router.mjs","webpack:///./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs","webpack:///./node_modules/workbox-routing/registerRoute.mjs","webpack:///./node_modules/workbox-strategies/_version.mjs","webpack:///./node_modules/workbox-strategies/CacheFirst.mjs","webpack:///./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs","webpack:///./node_modules/workbox-strategies/StaleWhileRevalidate.mjs","webpack:///./src/sw-predicate.js","webpack:///./node_modules/workbox-core/setCacheNameDetails.mjs","webpack:///./node_modules/workbox-precaching/precacheAndRoute.mjs","webpack:///./node_modules/workbox-routing/setDefaultHandler.mjs","webpack:///./node_modules/workbox-precaching/cleanupOutdatedCaches.mjs","webpack:///./node_modules/workbox-routing/setCatchHandler.mjs"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","_","e","messageGenerator","code","args","msg","length","JSON","stringify","WorkboxError_WorkboxError","Error","[object Object]","errorCode","details","super","this","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","join","cacheNames","updateDetails","keys","forEach","getGoogleAnalyticsName","userCacheName","getPrecacheName","getRuntimeName","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","callbacks","Set","DBWrapper","version","onupgradeneeded","onversionchange","_onversionchange","_name","_version","_onupgradeneeded","_db","db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","target","result","close","onsuccess","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","push","continue","storeNames","type","callback","onabort","oncomplete","method","methodsToWrap","readonly","readwrite","methods","entries","IDBObjectStore","async","_call","deleteDatabase","request","onblocked","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","hash","CacheTimestampsModel_CacheTimestampsModel","_cacheName","event","_handleUpgrade","objStore","createObjectStore","keyPath","createIndex","unique","timestamp","put","id","_getId","minTimestamp","maxCount","entriesDeleted","entriesNotDeletedCount","delete","CacheExpiration_CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_timestampModel","Date","now","undefined","urlsExpired","expireEntries","cache","caches","setTimestamp","getTimestamp","Infinity","Plugin_Plugin","_config","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","add","cacheExpiration","set","cachedResponse","isFresh","_isResponseDateFresh","_getCacheExpiration","updateTimestampDone","updateTimestamp","waitUntil","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","headerTime","getTime","isNaN","pluginEvents","pluginUtils","plugins","callbackName","plugin","matchWrapper","matchOptions","match","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","cacheWrapper","updatePlugins","oldResponse","executeQuotaErrorCallbacks","newResponse","fetchWrapper","fetch","fetchOptions","preloadResponse","possiblePreloadResponse","Request","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","REVISION_SEARCH_PARAM","createCacheKey","entry","urlObject","cacheKey","revision","originalURL","cacheKeyURL","searchParams","PrecacheController_PrecacheController","_urlsToCacheKeys","firstEntry","secondEntry","urlsToPrecache","urlsAlreadyPrecached","alreadyCachedRequests","alreadyCachedURLs","values","precacheRequests","_addURLToCache","all","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","deletedURLs","credentials","cacheWillUpdateCallback","cacheWillUpdate","redirected","clonedResponse","bodyPromise","body","blob","Response","statusText","cleanRedirect","ignoreSearch","getOrCreatePrecacheController_precacheController","getOrCreatePrecacheController","getCacheKeyForURL","options","urlsToCacheKeys","getURLsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","paramName","some","regExp","test","removeIgnoredSearchParams","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","possibleCacheKey","listenerAdded","precachePlugins_plugins","precachePlugins","newPlugins","listenersAdded","defaultMethod","normalizeHandler","handler","handle","Route_Route","RegExpRoute_RegExpRoute","exec","slice","Router_Router","_routes","routes","addEventListener","responsePromise","handleRequest","respondWith","data","payload","requestPromises","urlsToCache","ports","postMessage","protocol","startsWith","params","route","findMatchingRoute","_defaultHandler","_catchHandler","catch","matchResult","Array","isArray","constructor","routeIndex","indexOf","splice","getOrCreateDefaultRouter_defaultRouter","getOrCreateDefaultRouter","addFetchListener","addCacheListener","registerRoute","capture","captureUrl","RegExp","moduleName","funcName","CacheFirst_CacheFirst","_plugins","_fetchOptions","_matchOptions","makeRequest","_getFromNetwork","responseClone","cachePutPromise","cacheOkAndOpaquePlugin","StaleWhileRevalidate_StaleWhileRevalidate","isUsingCacheWillUpdate","fetchAndCachePromise","__precacheManifest","concat","precacheController","addToCacheList","install","activate","precachedURL","then","addRoute","currentPrecacheName","substringToFind","cacheNamesToDelete","includes","deleteOutdatedCaches","cachesDeleted","skipWaiting","setDefaultHandler","setCatchHandler","destination"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","try{self['workbox:core:4.1.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../../_version.mjs';\n\n\nexport const messages = {\n  'invalid-value': ({paramName, validValueDescription, value}) => {\n    if (!paramName || !validValueDescription) {\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\n    }\n    return `The '${paramName}' parameter was given a value with an ` +\n      `unexpected value. ${validValueDescription} Received a value of ` +\n      `${JSON.stringify(value)}.`;\n  },\n\n  'not-in-sw': ({moduleName}) => {\n    if (!moduleName) {\n      throw new Error(`Unexpected input to 'not-in-sw' error.`);\n    }\n    return `The '${moduleName}' must be used in a service worker.`;\n  },\n\n  'not-an-array': ({moduleName, className, funcName, paramName}) => {\n    if (!moduleName || !className || !funcName || !paramName) {\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className}.${funcName}()' must be an array.`;\n  },\n\n  'incorrect-type': ({expectedType, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedType || !paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}` +\n      `${funcName}()' must be of type ${expectedType}.`;\n  },\n\n  'incorrect-class': ({expectedClass, paramName, moduleName, className,\n    funcName, isReturnValueProblem}) => {\n    if (!expectedClass || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\n    }\n\n    if (isReturnValueProblem) {\n      return `The return value from ` +\n        `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n        `must be an instance of class ${expectedClass.name}.`;\n    }\n\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n      `must be an instance of class ${expectedClass.name}.`;\n  },\n\n  'missing-a-method': ({expectedMethod, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedMethod || !paramName || !moduleName || !className\n        || !funcName) {\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\n    }\n    return `${moduleName}.${className}.${funcName}() expected the ` +\n      `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n  },\n\n  'add-to-cache-list-unexpected-type': ({entry}) => {\n    return `An unexpected entry was passed to ` +\n    `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\n    `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\n    `strings with one or more characters, objects with a url property or ` +\n    `Request objects.`;\n  },\n\n  'add-to-cache-list-conflicting-entries': ({firstEntry, secondEntry}) => {\n    if (!firstEntry || !secondEntry) {\n      throw new Error(`Unexpected input to ` +\n        `'add-to-cache-list-duplicate-entries' error.`);\n    }\n\n    return `Two of the entries passed to ` +\n      `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n      `${firstEntry._entryId} but different revision details. Workbox is ` +\n      `is unable to cache and version the asset correctly. Please remove one ` +\n      `of the entries.`;\n  },\n\n  'plugin-error-request-will-fetch': ({thrownError}) => {\n    if (!thrownError) {\n      throw new Error(`Unexpected input to ` +\n        `'plugin-error-request-will-fetch', error.`);\n    }\n\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` +\n      `The thrown error message was: '${thrownError.message}'.`;\n  },\n\n  'invalid-cache-name': ({cacheNameId, value}) => {\n    if (!cacheNameId) {\n      throw new Error(\n          `Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n    }\n\n    return `You must provide a name containing at least one character for ` +\n      `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` +\n      `'${JSON.stringify(value)}'`;\n  },\n\n  'unregister-route-but-not-found-with-method': ({method}) => {\n    if (!method) {\n      throw new Error(`Unexpected input to ` +\n        `'unregister-route-but-not-found-with-method' error.`);\n    }\n\n    return `The route you're trying to unregister was not  previously ` +\n      `registered for the method type '${method}'.`;\n  },\n\n  'unregister-route-route-not-registered': () => {\n    return `The route you're trying to unregister was not previously ` +\n      `registered.`;\n  },\n\n  'queue-replay-failed': ({name}) => {\n    return `Replaying the background sync queue '${name}' failed.`;\n  },\n\n  'duplicate-queue-name': ({name}) => {\n    return `The Queue name '${name}' is already being used. ` +\n        `All instances of backgroundSync.Queue must be given unique names.`;\n  },\n\n  'expired-test-without-max-age': ({methodName, paramName}) => {\n    return `The '${methodName}()' method can only be used when the ` +\n      `'${paramName}' is used in the constructor.`;\n  },\n\n  'unsupported-route-type': ({moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter was an unsupported type. ` +\n      `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\n      `valid input types.`;\n  },\n\n  'not-array-of-class': ({value, expectedClass,\n    moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter must be an array of ` +\n      `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\n      `Please check the call to ${moduleName}.${className}.${funcName}() ` +\n      `to fix the issue.`;\n  },\n\n  'max-entries-or-age-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.maxEntries or config.maxAgeSeconds` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'statuses-or-headers-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.statuses or config.headers` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'invalid-string': ({moduleName, className, funcName, paramName}) => {\n    if (!paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\n    }\n    return `When using strings, the '${paramName}' parameter must start with ` +\n      `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\n      `Please see the docs for ${moduleName}.${funcName}() for ` +\n      `more info.`;\n  },\n\n  'channel-name-required': () => {\n    return `You must provide a channelName to construct a ` +\n    `BroadcastCacheUpdate instance.`;\n  },\n\n  'invalid-responses-are-same-args': () => {\n    return `The arguments passed into responsesAreSame() appear to be ` +\n      `invalid. Please ensure valid Responses are used.`;\n  },\n\n  'expire-custom-caches-only': () => {\n    return `You must provide a 'cacheName' property when using the ` +\n      `expiration plugin with a runtime caching strategy.`;\n  },\n\n  'unit-must-be-bytes': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n    }\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` +\n      `The Range header provided was \"${normalizedRangeHeader}\"`;\n  },\n\n  'single-range-only': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\n    }\n    return `Multiple ranges are not supported. Please use a  single start ` +\n      `value, and optional end value. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'invalid-range-values': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n    }\n    return `The Range header is missing both start and end values. At least ` +\n      `one of those values is needed. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'no-range-header': () => {\n    return `No Range header was found in the Request provided.`;\n  },\n\n  'range-not-satisfiable': ({size, start, end}) => {\n    return `The start (${start}) and end (${end}) values in the Range are ` +\n      `not satisfiable by the cached response, which is ${size} bytes.`;\n  },\n\n  'attempt-to-cache-non-get-request': ({url, method}) => {\n    return `Unable to cache '${url}' because it is a '${method}' request and ` +\n      `only 'GET' requests can be cached.`;\n  },\n\n  'cache-put-with-no-response': ({url}) => {\n    return `There was an attempt to cache '${url}' but the response was not ` +\n      `defined.`;\n  },\n\n  'no-response': ({url, error}) => {\n    let message = `The strategy could not generate a response for '${url}'.`;\n    if (error) {\n      message += ` The underlying error is ${error}.`;\n    }\n    return message;\n  },\n\n  'bad-precaching-response': ({url, status}) => {\n    return `The precaching request for '${url}' failed with an HTTP ` +\n      `status of ${status}.`;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\n\nimport '../_version.mjs';\n\nconst callbacks = new Set();\n\n/**\n * Adds a function to the set of callbacks that will be executed when there's\n * a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  callbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${callbacks.size} callbacks to clean up caches.`);\n  }\n\n  for (const callback of callbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {\n  executeQuotaErrorCallbacks,\n  registerQuotaErrorCallback,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","try{self['workbox:expiration:4.1.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    return await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesDeleted = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      cursor.delete();\n                      // We only need to return the URL, not the whole entry.\n                      entriesDeleted.push(cursor.value.url);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesDeleted);\n                }\n              };\n        });\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the last request to be used will be the request\n * that is removed from the Cache.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n","try{self['workbox:precaching:4.1.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst SUBSTRING_TO_FIND = '-precache-';\n\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nconst deleteOutdatedCaches = async (\n  currentPrecacheName,\n  substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await caches.keys();\n\n  const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n    return cacheName.includes(substringToFind) &&\n           cacheName.includes(self.registration.scope) &&\n           cacheName !== currentPrecacheName;\n  });\n\n  await Promise.all(\n      cacheNamesToDelete.map((cacheName) => caches.delete(cacheName)));\n\n  return cacheNamesToDelete;\n};\n\nexport {deleteOutdatedCaches};\n\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {executeQuotaErrorCallbacks} from './quota.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(request.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(request.url),\n    });\n  }\n\n  let responseToCache =\n      await _isResponseSafeToCache({request, response, event, plugins});\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(request.url)}' will not be ` +\n        `cached.`, responseToCache);\n    }\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (responseToCache.method && responseToCache.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: responseToCache.method,\n      });\n    }\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n    await matchWrapper({cacheName, request, matchOptions}) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(request.url)}.`);\n  }\n\n  try {\n    await cache.put(request, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      request,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n  let cachedResponse = await cache.match(request, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            request,\n            event,\n            matchOptions,\n            cachedResponse,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport '../_version.mjs';\n\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  const {revision, url} = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const originalURL = new URL(url, location);\n  const cacheKeyURL = new URL(url, location);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href,\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport async function cleanRedirect(response) {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, {\n    headers: clonedResponse.headers,\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n  });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {PrecacheController} from '../PrecacheController.mjs';\nimport '../_version.mjs';\n\n\nlet precacheController;\n\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './getOrCreatePrecacheController.mjs';\nimport {generateURLVariations} from './generateURLVariations.mjs';\nimport '../_version.mjs';\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n  const precacheController = getOrCreatePrecacheController();\n\n  const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n  for (const possibleURL of generateURLVariations(url, options)) {\n    const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n    if (possibleCacheKey) {\n      return possibleCacheKey;\n    }\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {removeIgnoredSearchParams} from './removeIgnoredSearchParams.mjs';\n\nimport '../_version.mjs';\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, {\n  ignoreURLParametersMatching,\n  directoryIndex,\n  cleanURLs,\n  urlManipulation,\n} = {}) {\n  const urlObject = new URL(url, location);\n  urlObject.hash = '';\n  yield urlObject.href;\n\n  const urlWithoutIgnoredParams = removeIgnoredSearchParams(\n      urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({url: urlObject});\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject,\n    ignoreURLParametersMatching) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './utils/getCacheKeyForURL.mjs';\nimport './_version.mjs';\n\n\nlet listenerAdded = false;\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  if (!listenerAdded) {\n    const cacheName = cacheNames.getPrecacheName();\n\n    addEventListener('fetch', (event) => {\n      const precachedURL = getCacheKeyForURL(event.request.url, {\n        cleanURLs,\n        directoryIndex,\n        ignoreURLParametersMatching,\n        urlManipulation,\n      });\n      if (!precachedURL) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Precaching did not find a match for ` +\n            getFriendlyURL(event.request.url));\n        }\n        return;\n      }\n\n      let responsePromise = caches.open(cacheName).then((cache) => {\n        return cache.match(precachedURL);\n      }).then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        // Fall back to the network if we don't have a cached response\n        // (perhaps due to manual cache cleanup).\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`The precached response for ` +\n          `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n          `Falling back to the network instead.`);\n        }\n\n        return fetch(precachedURL);\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        responsePromise = responsePromise.then((response) => {\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Precaching is responding to: ` +\n            getFriendlyURL(event.request.url));\n          logger.log(`Serving the precached url: ${precachedURL}`);\n\n          logger.groupCollapsed(`View request details here.`);\n          logger.log(event.request);\n          logger.groupEnd();\n\n          logger.groupCollapsed(`View response details here.`);\n          logger.log(response);\n          logger.groupEnd();\n\n          logger.groupEnd();\n          return response;\n        });\n      }\n\n      event.respondWith(responsePromise);\n    });\n\n    listenerAdded = true;\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst plugins = [];\n\nexport const precachePlugins = {\n  /*\n   * @return {Array}\n   * @private\n   */\n  get() {\n    return plugins;\n  },\n\n  /*\n   * @param {Array} newPlugins\n   * @private\n   */\n  add(newPlugins) {\n    plugins.push(...newPlugins);\n  },\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getOrCreatePrecacheController}\n  from './utils/getOrCreatePrecacheController.mjs';\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\nlet listenersAdded = false;\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.addToCacheList(entries);\n\n  if (!listenersAdded && entries.length > 0) {\n    const plugins = precachePlugins.get();\n\n    self.addEventListener('install', (event) => {\n      event.waitUntil(\n          precacheController.install({event, plugins})\n              .catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.error(`Service worker installation failed. It will ` +\n                  `be retried automatically during the next navigation.`);\n                }\n                // Re-throw the error to ensure installation fails.\n                throw error;\n              })\n      );\n    });\n\n    self.addEventListener('activate', (event) => {\n      event.waitUntil(precacheController.activate({event, plugins}));\n    });\n\n    listenersAdded = true;\n  }\n};\n","try{self['workbox:routing:4.1.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'PATCH',\n  'POST',\n  'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport '../_version.mjs';\n\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return {handle: handler};\n  }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox.routing.Route~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match',\n      });\n\n      if (method) {\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\n      }\n    }\n\n    // These values are referenced directly by Router so cannot be\n    // altered by minifification.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method || defaultMethod;\n  }\n}\n\nexport {Route};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from './Route.mjs';\nimport './_version.mjs';\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regulard expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * th ecaptured values will be passed to the\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern',\n      });\n    }\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if there's no match.\n      if (!result) {\n        return null;\n      }\n\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\n              `The regular expression '${regExp}' only partially matched ` +\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n            `handle cross-origin requests if they match the entire URL.`\n          );\n        }\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n}\n\nexport {RegExpRoute};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\n\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    self.addEventListener('fetch', (event) => {\n      const {request} = event;\n      const responsePromise = this.handleRequest({request, event});\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    self.addEventListener('message', async (event) => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {payload} = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({request});\n        }));\n\n        event.waitUntil(requestPromises);\n\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest({request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request',\n      });\n    }\n\n    const url = new URL(request.url, location);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n            `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let {params, route} = this.findMatchingRoute({url, request, event});\n    let handler = route && route.handler;\n\n    let debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n\n      logger.groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, request, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` +\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute({url, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request',\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({url, request, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if ((matchResult.constructor === Object &&\n            Object.keys(matchResult).length > 0)) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        }\n\n        // Return early if have a match.\n        return {route, params};\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError(\n          'unregister-route-but-not-found-with-method', {\n            method: route.method,\n          }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\n\nexport {Router};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Router} from '../Router.mjs';\nimport '../_version.mjs';\n\nlet defaultRouter;\n\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new Router();\n\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {Route} from './Route.mjs';\nimport {RegExpRoute} from './RegExpRoute.mjs';\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nexport const registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture',\n        });\n      }\n\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname : capture;\n\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        logger.debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n          `character (${wildcards}). Strings are now always interpreted as ` +\n          `exact matches; use a RegExp for partial or wildcard matches.`\n        );\n      }\n    }\n\n    const matchCallback = ({url}) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if ((url.pathname === captureUrl.pathname) &&\n            (url.origin !== captureUrl.origin)) {\n          logger.debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture',\n    });\n  }\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n","try{self['workbox:strategies:4.1.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {StaleWhileRevalidate};\n","/* eslint-disable no-undef, no-restricted-globals, no-underscore-dangle */\r\nimport { setCacheNameDetails } from 'workbox-core/setCacheNameDetails.mjs';\r\nimport { Plugin as ExpirationPlugin } from 'workbox-expiration/Plugin.mjs';\r\nimport { cleanupOutdatedCaches } from 'workbox-precaching/cleanupOutdatedCaches.mjs';\r\nimport { precacheAndRoute } from 'workbox-precaching/precacheAndRoute.mjs';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.mjs';\r\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.mjs';\r\nimport { setDefaultHandler } from 'workbox-routing/setDefaultHandler.mjs';\r\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.mjs';\r\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.mjs';\r\n\r\nconst prefix = 'james south portfolio';\r\nconst FALLBACK_IMAGE_7_URL = '/images/project7.0d460c6cd15e9ed3f683a05d1a282fbb.jpg';\r\nconst FALLBACK_IMAGE_9_URL = '/images/project9.fef701d08faf6c81fe7b50e9c45f79ad.jpg';\r\nconst FALLBACK_IMAGE_10_URL = '/images/project10.38128e3e605efa9c9dc9aecec6ffe3f7.jpg';\r\nconst FALLBACK_IMAGE_11_URL = '/images/project11.f50561f0701ba64315826deee4556c17.jpg';\r\n\r\nsetCacheNameDetails({ prefix });\r\nself.__precacheManifest = [].concat(self.__precacheManifest || []);\r\nprecacheAndRoute(self.__precacheManifest, {});\r\ncleanupOutdatedCaches();\r\n\r\naddEventListener('message', e => {\r\n  if (e.data && e.data.type === 'SKIP_WAITING') skipWaiting();\r\n});\r\n\r\nregisterRoute(\r\n  /\\.(?:js)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-lazy-js`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /\\.(?:png|jpg|jpeg|svg|gif)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-images`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 180,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.googleapis\\.com/,\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-google-fonts-css`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 30,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.gstatic\\.com/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-google-fonts`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nsetDefaultHandler(\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-default-handler`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nsetCatchHandler(({ event }) => {\r\n  if (event.request.destination === 'image' && /\\.gif$/.test(event.request.url) && !event.request.url.includes('explosion')) {\r\n    switch (event.request.url.match(/\\d{1,2}(?=\\.\\w{32})/)[0]) {\r\n      case '7':\r\n        return caches.match(FALLBACK_IMAGE_7_URL);\r\n      case '9':\r\n        return caches.match(FALLBACK_IMAGE_9_URL);\r\n      case '10':\r\n        return caches.match(FALLBACK_IMAGE_10_URL);\r\n      case '11':\r\n        return caches.match(FALLBACK_IMAGE_11_URL);\r\n    }\r\n  }\r\n  return Response.error();\r\n});\r\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addRoute} from './addRoute.mjs';\nimport {precache} from './precache.mjs';\nimport './_version.mjs';\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n  precache(entries);\n  addRoute(options);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\n\nimport './_version.mjs';\n\n/**\n * Define a default `handler` that's called when no routes explicitly\n * match the incoming request.\n *\n * Without a default handler, unmatched requests will go against the\n * network as if there were no service worker present.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setDefaultHandler\n */\nexport const setDefaultHandler = (handler) => {\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.setDefaultHandler(handler);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {deleteOutdatedCaches} from './utils/deleteOutdatedCaches.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @alias workbox.precaching.cleanupOutdatedCaches\n */\nexport const cleanupOutdatedCaches = () => {\n  addEventListener('activate', (event) => {\n    const cacheName = cacheNames.getPrecacheName();\n\n    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachesDeleted.length > 0) {\n          logger.log(`The following out-of-date precaches were cleaned up ` +\n              `automatically:`, cachesDeleted);\n        }\n      }\n    }));\n  });\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\n\nimport './_version.mjs';\n\n/**\n * If a Route throws an error while handling a request, this `handler`\n * will be called and given a chance to provide a response.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setCatchHandler\n */\nexport const setCatchHandler = (handler) => {\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.setCatchHandler(handler);\n};\n"],"sourceRoot":""}