{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/workbox-core/_version.mjs","webpack:///./node_modules/workbox-core/models/messages/messages.mjs","webpack:///./node_modules/workbox-core/models/messages/messageGenerator.mjs","webpack:///./node_modules/workbox-core/_private/WorkboxError.mjs","webpack:///./node_modules/workbox-core/_private/assert.mjs","webpack:///./node_modules/workbox-core/_private/cacheNames.mjs","webpack:///./node_modules/workbox-core/_private/getFriendlyURL.mjs","webpack:///./node_modules/workbox-core/models/quotaErrorCallbacks.mjs","webpack:///./node_modules/workbox-core/_private/DBWrapper.mjs","webpack:///./node_modules/workbox-core/_private/deleteDatabase.mjs","webpack:///./node_modules/workbox-expiration/_version.mjs","webpack:///./node_modules/workbox-expiration/models/CacheTimestampsModel.mjs","webpack:///./node_modules/workbox-expiration/CacheExpiration.mjs","webpack:///./node_modules/workbox-expiration/Plugin.mjs","webpack:///./node_modules/workbox-core/registerQuotaErrorCallback.mjs","webpack:///./node_modules/workbox-precaching/_version.mjs","webpack:///./node_modules/workbox-core/models/pluginEvents.mjs","webpack:///./node_modules/workbox-core/utils/pluginUtils.mjs","webpack:///./node_modules/workbox-core/_private/cacheWrapper.mjs","webpack:///./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.mjs","webpack:///./node_modules/workbox-core/_private/fetchWrapper.mjs","webpack:///./node_modules/workbox-precaching/utils/createCacheKey.mjs","webpack:///./node_modules/workbox-precaching/PrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/cleanRedirect.mjs","webpack:///./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.mjs","webpack:///./node_modules/workbox-precaching/utils/getCacheKeyForURL.mjs","webpack:///./node_modules/workbox-precaching/utils/generateURLVariations.mjs","webpack:///./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.mjs","webpack:///./node_modules/workbox-precaching/addRoute.mjs","webpack:///./node_modules/workbox-precaching/utils/addFetchListener.mjs","webpack:///./node_modules/workbox-precaching/utils/precachePlugins.mjs","webpack:///./node_modules/workbox-precaching/precache.mjs","webpack:///./node_modules/workbox-routing/_version.mjs","webpack:///./node_modules/workbox-routing/utils/constants.mjs","webpack:///./node_modules/workbox-routing/utils/normalizeHandler.mjs","webpack:///./node_modules/workbox-routing/Route.mjs","webpack:///./node_modules/workbox-routing/RegExpRoute.mjs","webpack:///./node_modules/workbox-routing/Router.mjs","webpack:///./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs","webpack:///./node_modules/workbox-routing/registerRoute.mjs","webpack:///./node_modules/workbox-strategies/_version.mjs","webpack:///./node_modules/workbox-strategies/CacheFirst.mjs","webpack:///./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs","webpack:///./node_modules/workbox-strategies/StaleWhileRevalidate.mjs","webpack:///./src/sw-predicate.js","webpack:///./node_modules/workbox-core/setCacheNameDetails.mjs","webpack:///./node_modules/workbox-precaching/precacheAndRoute.mjs","webpack:///./node_modules/workbox-routing/setDefaultHandler.mjs","webpack:///./node_modules/workbox-precaching/cleanupOutdatedCaches.mjs","webpack:///./node_modules/workbox-precaching/utils/deleteOutdatedCaches.mjs"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","_","e","messageGenerator","code","args","msg","length","JSON","stringify","Error","errorCode","details","super","this","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","join","cacheNames","updateDetails","keys","forEach","getGoogleAnalyticsName","userCacheName","getPrecacheName","getPrefix","getRuntimeName","getSuffix","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","quotaErrorCallbacks","Set","DBWrapper","version","onupgradeneeded","onversionchange","_onversionchange","_name","_version","_onupgradeneeded","_db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","target","result","close","onsuccess","db","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","push","continue","storeNames","type","callback","onabort","oncomplete","method","methodsToWrap","methods","entries","IDBObjectStore","async","_call","deleteDatabase","request","onblocked","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","hash","_cacheName","event","_handleUpgrade","objStore","createObjectStore","keyPath","createIndex","unique","timestamp","put","id","_getId","minTimestamp","maxCount","entriesToDelete","entriesNotDeletedCount","urlsDeleted","entry","delete","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_timestampModel","Date","now","undefined","urlsExpired","expireEntries","cache","caches","setTimestamp","getTimestamp","Infinity","_config","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","add","cacheExpiration","set","cachedResponse","isFresh","_isResponseDateFresh","_getCacheExpiration","updateTimestampDone","updateTimestamp","waitUntil","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","headerTime","getTime","isNaN","pluginEvents","pluginUtils","plugins","callbackName","plugin","matchWrapper","matchOptions","effectiveRequest","_getEffectiveRequest","match","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","cacheKeyWillBeUsedPlugins","Request","cacheWrapper","updatePlugins","oldResponse","executeQuotaErrorCallbacks","newResponse","fetchWrapper","fetch","fetchOptions","preloadResponse","possiblePreloadResponse","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","REVISION_SEARCH_PARAM","createCacheKey","urlObject","cacheKey","revision","originalURL","cacheKeyURL","searchParams","_urlsToCacheKeys","firstEntry","secondEntry","urlsToPrecache","urlsAlreadyPrecached","alreadyCachedRequests","alreadyCachedURLs","values","precacheRequests","_addURLToCache","all","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","deletedURLs","credentials","cacheWillUpdateCallback","cacheWillUpdate","redirected","clonedResponse","bodyPromise","body","blob","Response","statusText","cleanRedirect","ignoreSearch","getOrCreatePrecacheController","getCacheKeyForURL","options","urlsToCacheKeys","getURLsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","paramName","some","regExp","test","removeIgnoredSearchParams","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","possibleCacheKey","listenerAdded","addRoute","addEventListener","precachedURL","responsePromise","then","respondWith","addFetchListener","precachePlugins","newPlugins","installListener","precacheController","install","catch","activateListener","activate","defaultMethod","normalizeHandler","handler","handle","exec","slice","_routes","handleRequest","data","payload","requestPromises","urlsToCache","ports","postMessage","protocol","startsWith","params","route","findMatchingRoute","_defaultHandler","_catchHandler","routes","matchResult","Array","isArray","constructor","routeIndex","indexOf","splice","getOrCreateDefaultRouter","addCacheListener","registerRoute","capture","captureUrl","RegExp","moduleName","funcName","_plugins","_fetchOptions","_matchOptions","makeRequest","_getFromNetwork","responseClone","cachePutPromise","cacheOkAndOpaquePlugin","isUsingCacheWillUpdate","fetchAndCachePromise","__precacheManifest","concat","addToCacheList","currentPrecacheName","substringToFind","cacheNamesToDelete","includes","deleteOutdatedCaches","cachesDeleted","skipWaiting","setDefaultHandler"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../../_version.mjs';\n\n\nexport const messages = {\n  'invalid-value': ({paramName, validValueDescription, value}) => {\n    if (!paramName || !validValueDescription) {\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\n    }\n    return `The '${paramName}' parameter was given a value with an ` +\n      `unexpected value. ${validValueDescription} Received a value of ` +\n      `${JSON.stringify(value)}.`;\n  },\n\n  'not-in-sw': ({moduleName}) => {\n    if (!moduleName) {\n      throw new Error(`Unexpected input to 'not-in-sw' error.`);\n    }\n    return `The '${moduleName}' must be used in a service worker.`;\n  },\n\n  'not-an-array': ({moduleName, className, funcName, paramName}) => {\n    if (!moduleName || !className || !funcName || !paramName) {\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className}.${funcName}()' must be an array.`;\n  },\n\n  'incorrect-type': ({expectedType, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedType || !paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}` +\n      `${funcName}()' must be of type ${expectedType}.`;\n  },\n\n  'incorrect-class': ({expectedClass, paramName, moduleName, className,\n    funcName, isReturnValueProblem}) => {\n    if (!expectedClass || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\n    }\n\n    if (isReturnValueProblem) {\n      return `The return value from ` +\n        `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n        `must be an instance of class ${expectedClass.name}.`;\n    }\n\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n      `must be an instance of class ${expectedClass.name}.`;\n  },\n\n  'missing-a-method': ({expectedMethod, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedMethod || !paramName || !moduleName || !className\n        || !funcName) {\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\n    }\n    return `${moduleName}.${className}.${funcName}() expected the ` +\n      `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n  },\n\n  'add-to-cache-list-unexpected-type': ({entry}) => {\n    return `An unexpected entry was passed to ` +\n    `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\n    `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\n    `strings with one or more characters, objects with a url property or ` +\n    `Request objects.`;\n  },\n\n  'add-to-cache-list-conflicting-entries': ({firstEntry, secondEntry}) => {\n    if (!firstEntry || !secondEntry) {\n      throw new Error(`Unexpected input to ` +\n        `'add-to-cache-list-duplicate-entries' error.`);\n    }\n\n    return `Two of the entries passed to ` +\n      `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n      `${firstEntry._entryId} but different revision details. Workbox is ` +\n      `is unable to cache and version the asset correctly. Please remove one ` +\n      `of the entries.`;\n  },\n\n  'plugin-error-request-will-fetch': ({thrownError}) => {\n    if (!thrownError) {\n      throw new Error(`Unexpected input to ` +\n        `'plugin-error-request-will-fetch', error.`);\n    }\n\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` +\n      `The thrown error message was: '${thrownError.message}'.`;\n  },\n\n  'invalid-cache-name': ({cacheNameId, value}) => {\n    if (!cacheNameId) {\n      throw new Error(\n          `Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n    }\n\n    return `You must provide a name containing at least one character for ` +\n      `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` +\n      `'${JSON.stringify(value)}'`;\n  },\n\n  'unregister-route-but-not-found-with-method': ({method}) => {\n    if (!method) {\n      throw new Error(`Unexpected input to ` +\n        `'unregister-route-but-not-found-with-method' error.`);\n    }\n\n    return `The route you're trying to unregister was not  previously ` +\n      `registered for the method type '${method}'.`;\n  },\n\n  'unregister-route-route-not-registered': () => {\n    return `The route you're trying to unregister was not previously ` +\n      `registered.`;\n  },\n\n  'queue-replay-failed': ({name}) => {\n    return `Replaying the background sync queue '${name}' failed.`;\n  },\n\n  'duplicate-queue-name': ({name}) => {\n    return `The Queue name '${name}' is already being used. ` +\n        `All instances of backgroundSync.Queue must be given unique names.`;\n  },\n\n  'expired-test-without-max-age': ({methodName, paramName}) => {\n    return `The '${methodName}()' method can only be used when the ` +\n      `'${paramName}' is used in the constructor.`;\n  },\n\n  'unsupported-route-type': ({moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter was an unsupported type. ` +\n      `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\n      `valid input types.`;\n  },\n\n  'not-array-of-class': ({value, expectedClass,\n    moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter must be an array of ` +\n      `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\n      `Please check the call to ${moduleName}.${className}.${funcName}() ` +\n      `to fix the issue.`;\n  },\n\n  'max-entries-or-age-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.maxEntries or config.maxAgeSeconds` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'statuses-or-headers-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.statuses or config.headers` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'invalid-string': ({moduleName, className, funcName, paramName}) => {\n    if (!paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\n    }\n    return `When using strings, the '${paramName}' parameter must start with ` +\n      `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\n      `Please see the docs for ${moduleName}.${funcName}() for ` +\n      `more info.`;\n  },\n\n  'channel-name-required': () => {\n    return `You must provide a channelName to construct a ` +\n    `BroadcastCacheUpdate instance.`;\n  },\n\n  'invalid-responses-are-same-args': () => {\n    return `The arguments passed into responsesAreSame() appear to be ` +\n      `invalid. Please ensure valid Responses are used.`;\n  },\n\n  'expire-custom-caches-only': () => {\n    return `You must provide a 'cacheName' property when using the ` +\n      `expiration plugin with a runtime caching strategy.`;\n  },\n\n  'unit-must-be-bytes': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n    }\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` +\n      `The Range header provided was \"${normalizedRangeHeader}\"`;\n  },\n\n  'single-range-only': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\n    }\n    return `Multiple ranges are not supported. Please use a  single start ` +\n      `value, and optional end value. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'invalid-range-values': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n    }\n    return `The Range header is missing both start and end values. At least ` +\n      `one of those values is needed. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'no-range-header': () => {\n    return `No Range header was found in the Request provided.`;\n  },\n\n  'range-not-satisfiable': ({size, start, end}) => {\n    return `The start (${start}) and end (${end}) values in the Range are ` +\n      `not satisfiable by the cached response, which is ${size} bytes.`;\n  },\n\n  'attempt-to-cache-non-get-request': ({url, method}) => {\n    return `Unable to cache '${url}' because it is a '${method}' request and ` +\n      `only 'GET' requests can be cached.`;\n  },\n\n  'cache-put-with-no-response': ({url}) => {\n    return `There was an attempt to cache '${url}' but the response was not ` +\n      `defined.`;\n  },\n\n  'no-response': ({url, error}) => {\n    let message = `The strategy could not generate a response for '${url}'.`;\n    if (error) {\n      message += ` The underlying error is ${error}.`;\n    }\n    return message;\n  },\n\n  'bad-precaching-response': ({url, status}) => {\n    return `The precaching request for '${url}' failed with an HTTP ` +\n      `status of ${status}.`;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n// Callbacks to be executed whenever there's a quota error.\nconst quotaErrorCallbacks = new Set();\n\nexport {quotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      // TODO(philipwalton): we should be able to delete the\n                      // entry right here, but doing so causes an iteration\n                      // bug in Safari stable (fixed in TP). Instead we can\n                      // store the keys of the entries to delete, and then\n                      // delete the separate transactions.\n                      // https://github.com/GoogleChrome/workbox/issues/1978\n                      // cursor.delete();\n\n                      // We only need to return the URL, not the whole entry.\n                      entriesToDelete.push(cursor.value);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesToDelete);\n                }\n              };\n        });\n\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './_private/logger.mjs';\nimport {assert} from './_private/assert.mjs';\nimport {quotaErrorCallbacks} from './models/quotaErrorCallbacks.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  quotaErrorCallbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\nexport {registerQuotaErrorCallback};\n","try{self['workbox:precaching:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from '../_private/logger.mjs';\nimport {quotaErrorCallbacks} from '../models/quotaErrorCallbacks.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` +\n        `callbacks to clean up caches.`);\n  }\n\n  for (const callback of quotaErrorCallbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {executeQuotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport '../_version.mjs';\n\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  const {revision, url} = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const originalURL = new URL(url, location);\n  const cacheKeyURL = new URL(url, location);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href,\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport async function cleanRedirect(response) {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, {\n    headers: clonedResponse.headers,\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n  });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {PrecacheController} from '../PrecacheController.mjs';\nimport '../_version.mjs';\n\n\nlet precacheController;\n\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './getOrCreatePrecacheController.mjs';\nimport {generateURLVariations} from './generateURLVariations.mjs';\nimport '../_version.mjs';\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n  const precacheController = getOrCreatePrecacheController();\n\n  const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n  for (const possibleURL of generateURLVariations(url, options)) {\n    const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n    if (possibleCacheKey) {\n      return possibleCacheKey;\n    }\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {removeIgnoredSearchParams} from './removeIgnoredSearchParams.mjs';\n\nimport '../_version.mjs';\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, {\n  ignoreURLParametersMatching,\n  directoryIndex,\n  cleanURLs,\n  urlManipulation,\n} = {}) {\n  const urlObject = new URL(url, location);\n  urlObject.hash = '';\n  yield urlObject.href;\n\n  const urlWithoutIgnoredParams = removeIgnoredSearchParams(\n      urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({url: urlObject});\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject,\n    ignoreURLParametersMatching) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n","\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addFetchListener} from './utils/addFetchListener.mjs';\nimport './_version.mjs';\n\n\nlet listenerAdded = false;\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = (options) => {\n  if (!listenerAdded) {\n    addFetchListener(options);\n    listenerAdded = true;\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './getCacheKeyForURL.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n */\nexport const addFetchListener = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  const cacheName = cacheNames.getPrecacheName();\n\n  addEventListener('fetch', (event) => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation,\n    });\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` +\n          getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName).then((cache) => {\n      return cache.match(precachedURL);\n    }).then((cachedResponse) => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` +\n        `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n        `Falling back to the network instead.`);\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then((response) => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` +\n          getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedURL}`);\n\n        logger.groupCollapsed(`View request details here.`);\n        logger.log(event.request);\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View response details here.`);\n        logger.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst plugins = [];\n\nexport const precachePlugins = {\n  /*\n   * @return {Array}\n   * @private\n   */\n  get() {\n    return plugins;\n  },\n\n  /*\n   * @param {Array} newPlugins\n   * @private\n   */\n  add(newPlugins) {\n    plugins.push(...newPlugins);\n  },\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getOrCreatePrecacheController} from './utils/getOrCreatePrecacheController.mjs';\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\nconst installListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(\n      precacheController.install({event, plugins})\n          .catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(`Service worker installation failed. It will ` +\n              `be retried automatically during the next navigation.`);\n            }\n            // Re-throw the error to ensure installation fails.\n            throw error;\n          })\n  );\n};\n\nconst activateListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(precacheController.activate({event, plugins}));\n};\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.addToCacheList(entries);\n\n  if (entries.length > 0) {\n    // NOTE: these listeners will only be added once (even if the `precache()`\n    // method is called multiple times) because event listeners are implemented\n    // as a set, where each listener must be unique.\n    addEventListener('install', installListener);\n    addEventListener('activate', activateListener);\n  }\n};\n","try{self['workbox:routing:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'PATCH',\n  'POST',\n  'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport '../_version.mjs';\n\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return {handle: handler};\n  }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox.routing.Route~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match',\n      });\n\n      if (method) {\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\n      }\n    }\n\n    // These values are referenced directly by Router so cannot be\n    // altered by minifification.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method || defaultMethod;\n  }\n}\n\nexport {Route};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from './Route.mjs';\nimport './_version.mjs';\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regulard expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * th ecaptured values will be passed to the\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern',\n      });\n    }\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if there's no match.\n      if (!result) {\n        return null;\n      }\n\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\n              `The regular expression '${regExp}' only partially matched ` +\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n            `handle cross-origin requests if they match the entire URL.`\n          );\n        }\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n}\n\nexport {RegExpRoute};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\n\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    self.addEventListener('fetch', (event) => {\n      const {request} = event;\n      const responsePromise = this.handleRequest({request, event});\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    self.addEventListener('message', async (event) => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {payload} = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({request});\n        }));\n\n        event.waitUntil(requestPromises);\n\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest({request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request',\n      });\n    }\n\n    const url = new URL(request.url, location);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n            `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let {params, route} = this.findMatchingRoute({url, request, event});\n    let handler = route && route.handler;\n\n    let debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n\n      logger.groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, request, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` +\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute({url, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request',\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({url, request, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if ((matchResult.constructor === Object &&\n            Object.keys(matchResult).length > 0)) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        }\n\n        // Return early if have a match.\n        return {route, params};\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError(\n          'unregister-route-but-not-found-with-method', {\n            method: route.method,\n          }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\n\nexport {Router};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Router} from '../Router.mjs';\nimport '../_version.mjs';\n\nlet defaultRouter;\n\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new Router();\n\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {Route} from './Route.mjs';\nimport {RegExpRoute} from './RegExpRoute.mjs';\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nexport const registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture',\n        });\n      }\n\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname : capture;\n\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        logger.debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n          `character (${wildcards}). Strings are now always interpreted as ` +\n          `exact matches; use a RegExp for partial or wildcard matches.`\n        );\n      }\n    }\n\n    const matchCallback = ({url}) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if ((url.pathname === captureUrl.pathname) &&\n            (url.origin !== captureUrl.origin)) {\n          logger.debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture',\n    });\n  }\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n","try{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {StaleWhileRevalidate};\n","import { setCacheNameDetails } from 'workbox-core/setCacheNameDetails.mjs';\r\nimport { Plugin as ExpirationPlugin } from 'workbox-expiration/Plugin.mjs';\r\nimport { cleanupOutdatedCaches } from 'workbox-precaching/cleanupOutdatedCaches.mjs';\r\nimport { precacheAndRoute } from 'workbox-precaching/precacheAndRoute.mjs';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.mjs';\r\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.mjs';\r\nimport { setDefaultHandler } from 'workbox-routing/setDefaultHandler.mjs';\r\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.mjs';\r\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.mjs';\r\n\r\nconst prefix = 'james south portfolio';\r\n\r\nsetCacheNameDetails({ prefix });\r\nself.__precacheManifest = [].concat(self.__precacheManifest || []);\r\nprecacheAndRoute(self.__precacheManifest, {});\r\ncleanupOutdatedCaches();\r\n\r\naddEventListener('message', e => {\r\n  if (e.data && e.data.type === 'SKIP_WAITING') skipWaiting();\r\n});\r\n\r\nregisterRoute(\r\n  /\\.(?:js)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-js`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /\\.(?:png|pdf|jpe?g|svg|gif)$/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-images`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 180,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.googleapis\\.com/,\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-google-fonts-css`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 30,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nregisterRoute(\r\n  /^https:\\/\\/fonts\\.gstatic\\.com/,\r\n  new CacheFirst({\r\n    cacheName: `${prefix}-google-fonts`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxEntries: 1,\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\nsetDefaultHandler(\r\n  new StaleWhileRevalidate({\r\n    cacheName: `${prefix}-default-handler`,\r\n    plugins: [\r\n      new ExpirationPlugin({\r\n        maxAgeSeconds: 60 * 60 * 24 * 365,\r\n        purgeOnQuotaError: true,\r\n      }),\r\n    ],\r\n  })\r\n);\r\n\r\n// setCatchHandler(({ event }) => {\r\n//   if (event.request.destination === 'image' && /\\.gif$/.test(event.request.url) && !event.request.url.includes('explosion')) {\r\n//\r\n//\r\n//   }\r\n//   return Response.error();\r\n// });\r\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addRoute} from './addRoute.mjs';\nimport {precache} from './precache.mjs';\nimport './_version.mjs';\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n  precache(entries);\n  addRoute(options);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\n\nimport './_version.mjs';\n\n/**\n * Define a default `handler` that's called when no routes explicitly\n * match the incoming request.\n *\n * Without a default handler, unmatched requests will go against the\n * network as if there were no service worker present.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setDefaultHandler\n */\nexport const setDefaultHandler = (handler) => {\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.setDefaultHandler(handler);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {deleteOutdatedCaches} from './utils/deleteOutdatedCaches.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @alias workbox.precaching.cleanupOutdatedCaches\n */\nexport const cleanupOutdatedCaches = () => {\n  addEventListener('activate', (event) => {\n    const cacheName = cacheNames.getPrecacheName();\n\n    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachesDeleted.length > 0) {\n          logger.log(`The following out-of-date precaches were cleaned up ` +\n              `automatically:`, cachesDeleted);\n        }\n      }\n    }));\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst SUBSTRING_TO_FIND = '-precache-';\n\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nconst deleteOutdatedCaches = async (\n  currentPrecacheName,\n  substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await caches.keys();\n\n  const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n    return cacheName.includes(substringToFind) &&\n           cacheName.includes(self.registration.scope) &&\n           cacheName !== currentPrecacheName;\n  });\n\n  await Promise.all(\n      cacheNamesToDelete.map((cacheName) => caches.delete(cacheName)));\n\n  return cacheNamesToDelete;\n};\n\nexport {deleteOutdatedCaches};\n\n"],"sourceRoot":""}